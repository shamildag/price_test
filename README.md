### Test task for CSI
Используя язык Java необходимо написать метод объединения имеющихся цен с вновь импортированными из внешней системы.
Также необходимо написать unit тесты, для проверки хотя бы некоторых возможных вариантов.
#### Description
Каждый продаваемый товар, имеет свою цену. Цен у товара может быть несколько, каждая цена имеет свой номер,
принадлежность к отделу, период действия и значение в валюте.
В базе данных для каждого товара хранится история цен. В один момент времени может действовать только одна цена из цен,
с одинаковым номером и отделом. Обычно товар продается по первой цене, вторая, третья и четвертая могут используются
для применения скидок (т.е. сработало условие скидки, товар будет продан по цене номер 2).
Касса может обслуживать какой-то отдел, тогда она будет использовать при продаже цены указанные для этого отдела.

Правила объединения цен:
0. если товар еще не имеет цен, или имеющиеся цены не пересекаются в периодах действия с новыми, то новые цены просто добавляются к товару;
0. если имеющаяся цена пересекается в периоде действия с новой ценой, то:
0. если значения цен одинаковы, период действия имеющейся цены увеличивается согласно периоду новой цены;
0. если значения цен отличаются, добавляется новая цена, а период действия старой цены уменьшается согласно периоду новой цены.

Метод в качестве параметров получает коллекцию имеющихся цен, новых цен и должен вернуть коллекцию объединенных цен,
   	для дальнейшего сохранения в БД.

   	Пример полей класса «цена»:
   	long id; // идентификатор в БД
   	String product_code; // код товара
   	int number; // номер цены
   	int depart; // номер отдела
   	Date begin; // начало действия
   	Date end; // конец действия
   	long value; // значение цены в копейках

#####   Примеры объединений:
###### Имеющиеся цены

| Product_code | Number | Depart | Begin             |  End              | value |
|--------------|--------|--------|-------------------|-------------------|-------|
|122856        |  1     |    1   |01.01.2013 00:00:00|31.01.2013 23:59:59| 11000 |
|122856        |  2     |    1   |10.01.2013 00:00:00|20.01.2013 23:59:59| 99000 |
| 6654         |  1     |    2   |01.01.2013 00:00:00|31.01.2013 00:00:00| 5000  |
######   Новые цены
| Product_code | Number | Depart | Begin             |  End              | value |
|--------------|--------|--------|-------------------|-------------------|-------|
|   122856     |   1    |   1    |20.01.2013 00:00:00|20.02.2013 23:59:59| 11000 |
|   122856     |   2    |   1    |15.01.2013 00:00:00|25.01.2013 23:59:59| 92000 |
|   6654       |   1    |   2    |12.01.2013 00:00:00|13.01.2013 00:00:00|  4000 |

######   Результат
| Product_code | Number | Depart | Begin             |  End              | value |
|--------------|--------|--------|-------------------|-------------------|-------|
|   122856     |   1    |   1    |01.01.2013 00:00:00|20.02.2013 23:59:59| 11000 |
|   122856     |   2    |   1    |10.01.2013 00:00:00|15.01.2013 00:00:00| 99000 |
|   122856     |   2    |   1    |15.01.2013 00:00:00|25.01.2013 23:59:59| 92000 |
|   6654       |   1    |   2    |01.01.2013 00:00:00|12.01.2013 00:00:00| 5000  |
|   6654       |   1    |   2    |12.01.2013 00:00:00|13.01.2013 00:00:00| 4000  |
|   6654       |   1    |   2    |13.01.2013 00:00:00|31.01.2013 00:00:00| 5000  |

Вопросы к тестовому заданию: 
Поскольку составным ключем является связка: номер департамента + код продукта + номер цены
0. Нет timestamp'a, и в случае если во входяшем списке есть перекрывающиеся диапазон для специфичного составного ключа, 
то начинается проблема какой ключ взять.
0. Также понятно из вышеприведенного что в базе старые значения не перекрываются. 
Таким образом можно отсортировать по begin дате и не беспокоиться про перекрытия с end датами.  
Поскольку ни используемая база, ни желаемые библиотеки не специфицированны:
0. Использовалась старая версия Java 8
##### Реализация выполнена в двух вариантах
0. консольный вариант, использующий streams  в пакете **stream**
0. консольный вариант для Java7 , использующий ForkJoin, в пакете **forkjoin**